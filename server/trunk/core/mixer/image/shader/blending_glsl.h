/*
* Copyright (c) 2011 Sveriges Television AB <info@casparcg.com>
*
* This file is part of CasparCG (www.casparcg.com).
*
* CasparCG is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* CasparCG is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with CasparCG. If not, see <http://www.gnu.org/licenses/>.
*
* Author: Robert Nagy, ronag89@gmail.com
*/

#pragma once

static std::string get_adjustement_glsl()
{
	return 																																																						
		"\n	/*																																																				   "
		"\n	** Contrast, saturation, brightness																																												 "
		"\n	** Code of this function is from TGM's shader pack																																								   "
		"\n	** http://irrlicht.sourceforge.net/phpBB2/viewtopic.php?t=21057																																					"
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n	vec3 ContrastSaturationBrightness(vec3 color, float brt, float sat, float con)																																	   "
		"\n	{																																																				   "
		"\n		const float AvgLumR = 0.5;																																													   "
		"\n		const float AvgLumG = 0.5;																																													   "
		"\n		const float AvgLumB = 0.5;																																													   "
		"\n																																																					   "
		"\n		const vec3 LumCoeff = vec3(0.2125, 0.7154, 0.0721);																																							   "
		"\n																																																					   "
		"\n		vec3 AvgLumin = vec3(AvgLumR, AvgLumG, AvgLumB);																																							   "
		"\n		vec3 brtColor = color * brt;																																												   "
		"\n		vec3 intensity = vec3(dot(brtColor, LumCoeff));																																								   "
		"\n		vec3 satColor = mix(intensity, brtColor, sat);																																								   "
		"\n		vec3 conColor = mix(AvgLumin, satColor, con);																																								   "
		"\n		return conColor;																																															   "
		"\n	}																																																					"
		"\n																																																					   "
		"\n	/*																																																				   "
		"\n	** Gamma correction																																																	"
		"\n	** Details: http://blog.mouaif.org/2009/01/22/photoshop-gamma-correction-shader/																																   "
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n#define GammaCorrection(color, gamma)								pow(color, vec3(1.0 / gamma))				\n																									"
		"\n																																																					   "
		"\n	/*																																																				   "
		"\n	** Levels control (input (+gamma), output)																																										   "
		"\n	** Details: http://blog.mouaif.org/2009/01/28/levels-control-shader/																																			   "
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n#define LevelsControlInputRange(color, minInput, maxInput)				min(max(color - vec3(minInput), vec3(0.0)) / (vec3(maxInput) - vec3(minInput)), vec3(1.0))		\n										   "
		"\n#define LevelsControlInput(color, minInput, gamma, maxInput)				GammaCorrection(LevelsControlInputRange(color, minInput, maxInput), gamma)					\n												"	
		"\n#define LevelsControlOutputRange(color, minOutput, maxOutput) 			mix(vec3(minOutput), vec3(maxOutput), color)															\n								   "
		"\n#define LevelsControl(color, minInput, gamma, maxInput, minOutput, maxOutput) 	LevelsControlOutputRange(LevelsControlInput(color, minInput, gamma, maxInput), minOutput, maxOutput)	\n							"
		;
}

static std::string get_blend_glsl()
{
	static std::string glsl = 
		"\n	/*																																																				   "
		"\n	** Photoshop & misc math																																														   "
		"\n	** Blending modes, RGB/HSL/Contrast/Desaturate, levels control																																					   "
		"\n	**																																																				   "
		"\n	** Romain Dura | Romz																																															   "
		"\n	** Blog: http://blog.mouaif.org																																												   "
		"\n	** Post: http://blog.mouaif.org/?p=94																																											   "
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n																																																					   "
		"\n	/*																																																				   "
		"\n	** Desaturation																																																   "
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n	vec4 Desaturate(vec3 color, float Desaturation)																																								   "
		"\n	{																																																				   "
		"\n		vec3 grayXfer = vec3(0.3, 0.59, 0.11);																																										   "
		"\n		vec3 gray = vec3(dot(grayXfer, color));																																										   "
		"\n		return vec4(mix(color, gray, Desaturation), 1.0);																																							   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n																																																					   "
		"\n	/*																																																				   "
		"\n	** Hue, saturation, luminance																																													   "
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n	vec3 RGBToHSL(vec3 color)																																														   "
		"\n	{																																																				   "
		"\n		vec3 hsl; 																															   "
		"\n																																																					   "
		"\n		float fmin = min(min(color.r, color.g), color.b);    																																   "
		"\n		float fmax = max(max(color.r, color.g), color.b);  																																   "
		"\n		float delta = fmax - fmin;            																																			   "
		"\n																																																					   "
		"\n		hsl.z = (fmax + fmin) / 2.0;																																							   "
		"\n																																																					   "
		"\n		if (delta == 0.0)																																						   "
		"\n		{																																																			   "
		"\n			hsl.x = 0.0;																																												   "
		"\n			hsl.y = 0.0;																																											   "
		"\n		}																																																			   "
		"\n		else                                  																																			   "
		"\n		{																																																			   "
		"\n			if (hsl.z < 0.5)																																														   "
		"\n				hsl.y = delta / (fmax + fmin); 																																				   "
		"\n			else																																																	   "
		"\n				hsl.y = delta / (2.0 - fmax - fmin); 																																				   "
		"\n																																																					   "
		"\n			float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;																																		   "
		"\n			float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;																																		   "
		"\n			float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;																																		   "
		"\n																																																					   "
		"\n			if (color.r == fmax )																																													   "
		"\n				hsl.x = deltaB - deltaG; 																																								   "
		"\n			else if (color.g == fmax)																																												   "
		"\n				hsl.x = (1.0 / 3.0) + deltaR - deltaB; 																																					   "
		"\n			else if (color.b == fmax)																																												   "
		"\n				hsl.x = (2.0 / 3.0) + deltaG - deltaR;																																					   "
		"\n																																																					   "
		"\n			if (hsl.x < 0.0)																																														   "
		"\n				hsl.x += 1.0;																																											   "
		"\n			else if (hsl.x > 1.0)																																													   "
		"\n				hsl.x -= 1.0;																																											   "
		"\n		}																																																			   "
		"\n																																																					   "
		"\n		return hsl;																																																	   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n	float HueToRGB(float f1, float f2, float hue)																																									   "
		"\n	{																																																				   "
		"\n		if (hue < 0.0)																																																   "
		"\n			hue += 1.0;																																																   "
		"\n		else if (hue > 1.0)																																															   "
		"\n			hue -= 1.0;																																																   "
		"\n		float res;																																																	   "
		"\n		if ((6.0 * hue) < 1.0)																																														   "
		"\n			res = f1 + (f2 - f1) * 6.0 * hue;																																										   "
		"\n		else if ((2.0 * hue) < 1.0)																																													   "
		"\n			res = f2;																																																   "
		"\n		else if ((3.0 * hue) < 2.0)																																													   "
		"\n			res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;																																						   "
		"\n		else																																																		   "
		"\n			res = f1;																																																   "
		"\n		return res;																																																	   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n	vec3 HSLToRGB(vec3 hsl)																																														   "
		"\n	{																																																				   "
		"\n		vec3 rgb;																																																	   "
		"\n																																																					   "
		"\n		if (hsl.y == 0.0)																																															   "
		"\n			rgb = vec3(hsl.z);																																									   "
		"\n		else																																																		   "
		"\n		{																																																			   "
		"\n			float f2;																																																   "
		"\n																																																					   "
		"\n			if (hsl.z < 0.5)																																														   "
		"\n				f2 = hsl.z * (1.0 + hsl.y);																																											   "
		"\n			else																																																	   "
		"\n				f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);																																								   "
		"\n																																																					   "
		"\n			float f1 = 2.0 * hsl.z - f2;																																											   "
		"\n																																																					   "
		"\n			rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));																																							   "
		"\n			rgb.g = HueToRGB(f1, f2, hsl.x);																																										   "
		"\n			rgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));																																								   "
		"\n		}																																																			   "
		"\n																																																					   "
		"\n		return rgb;																																																	   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n																																																						   "
		"\n																																																					   "
		"\n																																																					   "
		"\n	/*																																																				   "
		"\n	** Float blending modes																																														   "
		"\n	** Adapted from here: http://www.nathanm.com/photoshop-blending-math/																																			   "
		"\n	** But I modified the HardMix (wrong condition), Overlay, SoftLight, ColorDodge, ColorBurn, VividLight, PinLight (inverted layers) ones to have correct results												   "
		"\n	*/																																																				   "
		"\n																																																\n					   "
		"\n#define BlendLinearDodgef 					BlendAddf																																		\n						   "
		"\n#define BlendLinearBurnf 					BlendSubstractf																																	\n						   "
		"\n#define BlendAddf(base, blend) 				min(base + blend, 1.0)																															\n					   "
		"\n#define BlendSubstractf(base, blend) 		max(base + blend - 1.0, 0.0)																													\n						   "
		"\n#define BlendLightenf(base, blend) 		max(blend, base)																																	\n				   "
		"\n#define BlendDarkenf(base, blend) 			min(blend, base)																																\n						   "
		"\n#define BlendLinearLightf(base, blend) 	(blend < 0.5 ? BlendLinearBurnf(base, (2.0 * blend)) : BlendLinearDodgef(base, (2.0 * (blend - 0.5))))												\n				   "
		"\n#define BlendScreenf(base, blend) 			(1.0 - ((1.0 - base) * (1.0 - blend)))																											\n						   "
		"\n#define BlendOverlayf(base, blend) 		(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))																	\n					   "
		"\n#define BlendSoftLightf(base, blend) 		((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))	\n						   "
		"\n#define BlendColorDodgef(base, blend) 		((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))																						\n						   "
		"\n#define BlendColorBurnf(base, blend) 		((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))																				\n						   "
		"\n#define BlendVividLightf(base, blend)		((blend < 0.5) ? BlendColorBurnf(base, (2.0 * blend)) : BlendColorDodgef(base, (2.0 * (blend - 0.5))))											\n						   "
		"\n#define BlendPinLightf(base, blend) 		((blend < 0.5) ? BlendDarkenf(base, (2.0 * blend)) : BlendLightenf(base, (2.0 *(blend - 0.5))))														\n					   "
		"\n#define BlendHardMixf(base, blend) 		((BlendVividLightf(base, blend) < 0.5) ? 0.0 : 1.0)																									\n					   "
		"\n#define BlendReflectf(base, blend) 		((blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0))																					\n				   "
		"\n																																																					   "
		"\n																																																					   "
		"\n	/*																																																				   "
		"\n	** Vector3 blending modes																																														   "
		"\n	*/																																																				   "
		"\n																																																					   "
		"\n#define Blend(base, blend, funcf) 			vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))				\n																			   "
		"\n																																			\n																		   "
		"\n#define BlendNormal(base, blend) 			(blend)																						\n																			   "
		"\n#define BlendLighten						BlendLightenf																					\n																			   "
		"\n#define BlendDarken						BlendDarkenf																					\n																			   "
		"\n#define BlendMultiply(base, blend) 		(base * blend)																					\n																	   "
		"\n#define BlendAverage(base, blend) 			((base + blend) / 2.0)																		\n																			   "
		"\n#define BlendAdd(base, blend) 				min(base + blend, vec3(1.0))																\n																				   "
		"\n#define BlendSubstract(base, blend) 		max(base + blend - vec3(1.0), vec3(0.0))														\n																		   "
		"\n#define BlendDifference(base, blend) 		abs(base - blend)																			\n																			   "
		"\n#define BlendNegation(base, blend) 		(vec3(1.0) - abs(vec3(1.0) - base - blend))														\n																		   "
		"\n#define BlendExclusion(base, blend) 		(base + blend - 2.0 * base * blend)																\n																		   "
		"\n#define BlendScreen(base, blend) 			Blend(base, blend, BlendScreenf)															\n																			   "
		"\n#define BlendOverlay(base, blend) 			Blend(base, blend, BlendOverlayf)															\n																			   "
		"\n#define BlendSoftLight(base, blend) 		Blend(base, blend, BlendSoftLightf)																\n																		   "
		"\n#define BlendHardLight(base, blend) 		BlendOverlay(blend, base)																		\n																		   "
		"\n#define BlendColorDodge(base, blend) 		Blend(base, blend, BlendColorDodgef)														\n																			   "
		"\n#define BlendColorBurn(base, blend) 		Blend(base, blend, BlendColorBurnf)																\n																		   "
		"\n#define BlendLinearDodge					BlendAdd																						\n																			   "
		"\n#define BlendLinearBurn					BlendSubstract																					\n																			   "
		"\n#define BlendLinearLight(base, blend) 		Blend(base, blend, BlendLinearLightf)														\n																			   "
		"\n#define BlendVividLight(base, blend) 		Blend(base, blend, BlendVividLightf)														\n																			   "
		"\n#define BlendPinLight(base, blend) 		Blend(base, blend, BlendPinLightf)																\n																	   "
		"\n#define BlendHardMix(base, blend) 			Blend(base, blend, BlendHardMixf)															\n																			   "
		"\n#define BlendReflect(base, blend) 			Blend(base, blend, BlendReflectf)															\n																			   "
		"\n#define BlendGlow(base, blend) 			BlendReflect(blend, base)																		\n																		   "
		"\n#define BlendPhoenix(base, blend) 			(min(base, blend) - max(base, blend) + vec3(1.0))											\n																			   "
		"\n#define BlendOpacity(base, blend, F, O) 	(F(base, blend) * O + blend * (1.0 - O))														\n																			   "
		"\n																																																					   "
		"\n																																																					   "
		"\n	vec3 BlendHue(vec3 base, vec3 blend)																																											   "
		"\n	{																																																				   "
		"\n		vec3 baseHSL = RGBToHSL(base);																																												   "
		"\n		return HSLToRGB(vec3(RGBToHSL(blend).r, baseHSL.g, baseHSL.b));																																				   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n	vec3 BlendSaturation(vec3 base, vec3 blend)																																									   "
		"\n	{																																																				   "
		"\n		vec3 baseHSL = RGBToHSL(base);																																												   "
		"\n		return HSLToRGB(vec3(baseHSL.r, RGBToHSL(blend).g, baseHSL.b));																																				   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n	vec3 BlendColor(vec3 base, vec3 blend)																																											   "
		"\n	{																																																				   "
		"\n		vec3 blendHSL = RGBToHSL(blend);																																											   "
		"\n		return HSLToRGB(vec3(blendHSL.r, blendHSL.g, RGBToHSL(base).b));																																			   "
		"\n	}																																																				   "
		"\n																																																					   "
		"\n	vec3 BlendLuminosity(vec3 base, vec3 blend)																																									   "
		"\n	{																																																				   "
		"\n		vec3 baseHSL = RGBToHSL(base);																																												   "
		"\n		return HSLToRGB(vec3(baseHSL.r, baseHSL.g, RGBToHSL(blend).b));																																				   "
		"\n	}																																																				   "
		"\n																																																	   "
		;
																																																						   
		return glsl;
}